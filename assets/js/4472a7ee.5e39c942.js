"use strict";(self.webpackChunkterranetes=self.webpackChunkterranetes||[]).push([[6410],{3905:(e,t,s)=>{s.d(t,{Zo:()=>d,kt:()=>h});var r=s(7294);function p(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function a(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,r)}return s}function i(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?a(Object(s),!0).forEach((function(t){p(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):a(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function o(e,t){if(null==e)return{};var s,r,p=function(e,t){if(null==e)return{};var s,r,p={},a=Object.keys(e);for(r=0;r<a.length;r++)s=a[r],t.indexOf(s)>=0||(p[s]=e[s]);return p}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)s=a[r],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(p[s]=e[s])}return p}var n=r.createContext({}),c=function(e){var t=r.useContext(n),s=t;return e&&(s="function"==typeof e?e(t):i(i({},t),e)),s},d=function(e){var t=c(e.components);return r.createElement(n.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var s=e.components,p=e.mdxType,a=e.originalType,n=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),y=c(s),h=p,k=y["".concat(n,".").concat(h)]||y[h]||l[h]||a;return s?r.createElement(k,i(i({ref:t},d),{},{components:s})):r.createElement(k,i({ref:t},d))}));function h(e,t){var s=arguments,p=t&&t.mdxType;if("string"==typeof e||p){var a=s.length,i=new Array(a);i[0]=y;var o={};for(var n in t)hasOwnProperty.call(t,n)&&(o[n]=t[n]);o.originalType=e,o.mdxType="string"==typeof e?e:p,i[1]=o;for(var c=2;c<a;c++)i[c]=s[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,s)}y.displayName="MDXCreateElement"},575:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>n,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=s(7462),p=(s(7294),s(3905));const a={title:"revisions.terraform.appvia.io",linkTitle:"Revision",sidebar_position:1},i="Revision",o={unversionedId:"reference/revisions.terraform.appvia.io",id:"reference/revisions.terraform.appvia.io",title:"revisions.terraform.appvia.io",description:"Revision is the schema for a revision",source:"@site/docs/terranetes-controller/reference/revisions.terraform.appvia.io.md",sourceDirName:"reference",slug:"/reference/revisions.terraform.appvia.io",permalink:"/terranetes-controller/reference/revisions.terraform.appvia.io",draft:!1,editUrl:"https://github.com/appvia/terranetes/tree/master/docs/terranetes-controller/reference/revisions.terraform.appvia.io.md",tags:[],version:"current",lastUpdatedBy:"Rohith Jayawardene",lastUpdatedAt:1696672868,formattedLastUpdatedAt:"Oct 7, 2023",sidebarPosition:1,frontMatter:{title:"revisions.terraform.appvia.io",linkTitle:"Revision",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"providers.terraform.appvia.io",permalink:"/terranetes-controller/reference/providers.terraform.appvia.io"},next:{title:"CLI Reference",permalink:"/terranetes-controller/category/cli-reference"}},n={},c=[],d={toc:c};function l(e){let{components:t,...s}=e;return(0,p.kt)("wrapper",(0,r.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"revision"},"Revision"),(0,p.kt)("p",{class:"crd-description"},"Revision is the schema for a revision"),(0,p.kt)("dl",{class:"crd-meta"},(0,p.kt)("dt",{class:"fullname"},"Full name:"),(0,p.kt)("dd",{class:"fullname"},"revisions.terraform.appvia.io"),(0,p.kt)("dt",{class:"groupname"},"Group:"),(0,p.kt)("dd",{class:"groupname"},"terraform.appvia.io"),(0,p.kt)("dt",{class:"singularname"},"Singular name:"),(0,p.kt)("dd",{class:"singularname"},"revision"),(0,p.kt)("dt",{class:"pluralname"},"Plural name:"),(0,p.kt)("dd",{class:"pluralname"},"revisions"),(0,p.kt)("dt",{class:"scope"},"Scope:"),(0,p.kt)("dd",{class:"scope"},"Cluster"),(0,p.kt)("dt",{class:"versions"},"Versions:"),(0,p.kt)("dd",{class:"versions"},(0,p.kt)("a",{class:"version",href:"#v1alpha1",title:"Show schema for version v1alpha1"},"v1alpha1"))),(0,p.kt)("div",{class:"crd-schema-version"},(0,p.kt)("h2",{id:"v1alpha1"},"Version v1alpha1"),(0,p.kt)("h3",{id:"property-details-v1alpha1"},"Properties"),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.apiVersion"},".apiVersion")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: ",(0,p.kt)("a",{href:"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"},"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"))))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.kind"},".kind")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: ",(0,p.kt)("a",{href:"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"},"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"))))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.metadata"},".metadata")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec"},".spec")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"RevisionSpec defines the desired state of a configuration plan revision")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration"},".spec.configuration")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Configuration is the configuration which this revision is providing to the consumer.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.auth"},".spec.configuration.auth")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Auth is used to configure any options required when the source of the terraform module is private or requires credentials to retrieve. This could be SSH keys or git user/pass or AWS credentials for an s3 bucket.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.auth.name"},".spec.configuration.auth.name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"name is unique within a namespace to reference a secret resource.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.auth.namespace"},".spec.configuration.auth.namespace")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"namespace defines the space within which the secret name must be unique.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.enableAutoApproval"},".spec.configuration.enableAutoApproval")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"boolean")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"EnableAutoApproval when enabled indicates the configuration does not need to be manually approved. On a change to the configuration, the controller will automatically approve the configuration. Note it still needs to adhere to any checks or policies.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.enableDriftDetection"},".spec.configuration.enableDriftDetection")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"boolean")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"EnableDriftDetection when enabled run periodic reconciliation configurations looking for any drift between the expected and current state. If any drift is detected the status is changed and a kubernetes event raised.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.module"},".spec.configuration.module")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Module is the URL to the source of the terraform module. The format of the URL is a direct implementation of terraform\u2019s module reference. Please see the following repository for more details ",(0,p.kt)("a",{href:"https://github.com/hashicorp/go-getter"},"https://github.com/hashicorp/go-getter"))))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.plan"},".spec.configuration.plan")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Plan is an optional reference to a plan this configuration is associated with. If not set and a policy exists to enforce a plan, the configuration will be rejected.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.plan.name"},".spec.configuration.plan.name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is the name of the plan this configuration is associated with")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.plan.revision"},".spec.configuration.plan.revision")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Revision is the revision of the plan this configuration is associated with")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.providerRef"},".spec.configuration.providerRef")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"ProviderRef is the reference to the provider which should be used to execute this configuration.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.providerRef.name"},".spec.configuration.providerRef.name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is the name of the provider which contains the credentials to use for this configuration.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.providerRef.namespace"},".spec.configuration.providerRef.namespace")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Namespace is the namespace of the provider itself.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.terraformVersion"},".spec.configuration.terraformVersion")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"TerraformVersion provides the ability to override the default terraform version. Before changing this field its best to consult with platform administrator. As the value of this field is used to change the tag of the terraform container image.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom"},".spec.configuration.valueFrom")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"ValueFromSource is a collection of value from sources, where the source of the value is taken from a secret")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom[*]"},".spec.configuration.valueFrom[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"ValueFromSource defines a value which is taken from a secret")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom[*].context"},".spec.configuration.valueFrom[*].context")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Context is the context is the name of the terraform context where the value should be retrieved from")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom[*].key"},".spec.configuration.valueFrom[*].key")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Key is the key in the secret which we should used for the value")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom[*].name"},".spec.configuration.valueFrom[*].name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is the name which we use when injecting the value into the terraform code i.e. the secret may contain data.DB_HOST but you call this database_hostname. Note, for backwards compatiability if no name is provided, we using the key at the name")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom[*].optional"},".spec.configuration.valueFrom[*].optional")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"boolean")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Optional indicates the secret can be optional, i.e if the secret does not exist, or the key is not contained in the secret, we ignore the error")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.valueFrom[*].secret"},".spec.configuration.valueFrom[*].secret")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Secret is the name of the secret in the configuration namespace")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.variables"},".spec.configuration.variables")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Variables provides the inputs for the terraform module itself. These are passed to the terraform executor and used to execute the plan, apply and destroy phases.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.writeConnectionSecretToRef"},".spec.configuration.writeConnectionSecretToRef")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"WriteConnectionSecretToRef is the name for a secret. On execution of the terraform module any module outputs are written to this secret. The outputs are automatically uppercased and ready to be consumed as environment variables. WriteConnectionSecretRef is the secret where the terraform outputs will be written.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.writeConnectionSecretToRef.keys"},".spec.configuration.writeConnectionSecretToRef.keys")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Keys is a collection of name used to filter the terraform output. By default all keys from the output of the terraform state are written to the connection secret. Here we can define exactly which keys we want from that output.")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.writeConnectionSecretToRef.keys[*]"},".spec.configuration.writeConnectionSecretToRef.keys[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.configuration.writeConnectionSecretToRef.name"},".spec.configuration.writeConnectionSecretToRef.name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is the of the secret where you want to the terraform output to be written. The terraform outputs will be written to the secret as a key value pair. All are uppercased can read to be consumed by the workload.")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies"},".spec.dependencies")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Dependencies is a collection of dependencies which this revision depends on such as a Provider, Terranetes version, or Revision")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*]"},".spec.dependencies[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"RevisionDependency defined a dependency for this revision. Currently we support Provider, Revision or Terranetes version")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].context"},".spec.dependencies[*].context")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Revision indicates this revision has a dependency on a context resource")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].context.cloud"},".spec.dependencies[*].context.cloud")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Cloud is the name of the cloud vendor we are dependent on, such as aws, azurerm, which the context resource is associated with")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].context.name"},".spec.dependencies[*].context.name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is the name of the context resource we are dependent on")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].provider"},".spec.dependencies[*].provider")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Provider indicates this revision has a dependency on a provider resource")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].provider.cloud"},".spec.dependencies[*].provider.cloud")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Cloud is the name of the cloud vendor we are dependent on, such as aws, azurerm, The controller we ensure we have the provider installed before we can apply the configuration")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].terranetes"},".spec.dependencies[*].terranetes")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Terranetes indicates this revision has a dependency on a terranetes controller")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.dependencies[*].terranetes.version"},".spec.dependencies[*].terranetes.version")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Version is used to specify the version of the terranetes resource we are dependent on. This format is based on Semantic Versioning 2.0.0 and can use \u2018>=\u2019, \u2018>\u2019, \u2018<=\u2019, and \u2018<\u2019")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs"},".spec.inputs")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Inputs is a collection of inputs which this revision the consumer of this revision can or must provide. This is usually limited to contextual information such as a name for the database, the size required, a bucket name, or policy.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs[*]"},".spec.inputs[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"RevisionInput is a user defined input for a revision, such as a database name or a cache size etc.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs[*].default"},".spec.inputs[*].default")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Default is the default value for this input, this is a map which must contain the field \u2018value\u2019 => \u2018default value\u2019. Default values can be any simple of complex type, such as string, int, bool, etc.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs[*].description"},".spec.inputs[*].description")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Description is a short description of the input and its purpose, capabilities, etc.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs[*].key"},".spec.inputs[*].key")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Key is the name of the variable when presented to the terraform module. If this field is not specified, the name will be used as the key instead")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs[*].required"},".spec.inputs[*].required")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"boolean")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Required indicates whether this input is required or not by the revision")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.inputs[*].type"},".spec.inputs[*].type")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Type is the format of the input, such as string, int, bool, etc.")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan"},".spec.plan")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Plan contains the information related to the name, version, description of the revision.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan.categories"},".spec.plan.categories")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Categories is a list of categories which this revision is grouped by, such as database, cache, etc.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan.categories[*]"},".spec.plan.categories[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan.changeLog"},".spec.plan.changeLog")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"ChangeLog provides a human readable list of changes for this revision")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan.description"},".spec.plan.description")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Description is a short description of the revision and its purpose, capabilities, etc.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan.name"},".spec.plan.name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is the name which this revision is grouped by, such as mysql, redis, etc. Multiple revisions can be grouped by the same name, presented as a list of revisions for a single plan name")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.plan.revision"},".spec.plan.revision")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Revision is the version of the revision, such as 1.0.0, 1.0.1, etc.")))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status"},".status")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"RevisionStatus defines the observed state of a terraform")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions"},".status.conditions")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Conditions represents the observations of the resource\u2019s current state.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*]"},".status.conditions[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Condition is the current observed condition of some aspect of a resource")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].detail"},".status.conditions[*].detail")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Detail is any additional human-readable detail to understand this condition, for example, the full underlying error which caused an issue")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].lastTransitionTime"},".status.conditions[*].lastTransitionTime")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"LastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].message"},".status.conditions[*].message")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Message is a human readable message indicating details about the transition. This may be an empty string.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].name"},".status.conditions[*].name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is a human-readable name for this condition.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].observedGeneration"},".status.conditions[*].observedGeneration")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"ObservedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].reason"},".status.conditions[*].reason")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Reason contains a programmatic identifier indicating the reason for the condition\u2019s last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].status"},".status.conditions[*].status")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Status of the condition, one of True, False, Unknown.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].type"},".status.conditions[*].type")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Type of condition in CamelCase or in foo.example.com/CamelCase. \u2014 Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.inUse"},".status.inUse")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"InUse is the number of cloud resources which are currently using this revision")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastReconcile"},".status.lastReconcile")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"LastReconcile describes the generation and time of the last reconciliation")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastReconcile.generation"},".status.lastReconcile.generation")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Generation is the generation reconciled on the last reconciliation")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastReconcile.time"},".status.lastReconcile.time")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Time is the last time the resource was reconciled")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastSuccess"},".status.lastSuccess")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"LastSuccess descibes the generation and time of the last reconciliation which resulted in a Success status")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastSuccess.generation"},".status.lastSuccess.generation")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Generation is the generation reconciled on the last reconciliation")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastSuccess.time"},".status.lastSuccess.time")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Time is the last time the resource was reconciled"))))))}l.isMDXComponent=!0}}]);