"use strict";(self.webpackChunkterranetes=self.webpackChunkterranetes||[]).push([["668"],{3070:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,contentTitle:()=>a,default:()=>d,assets:()=>c,toc:()=>l,frontMatter:()=>r});var t=JSON.parse('{"id":"admin/policy/checkov","title":"Checkov Policy","description":"The implementation of a security policy ensures that platform teams can confidently allow self-service capabilities that adhere to the organization\'s best practices. As part of the plan stage, all Terraform configurations undergo a security check to validate their compliance.","source":"@site/docs/terranetes-controller/admin/policy/checkov.md","sourceDirName":"admin/policy","slug":"/admin/policy/checkov","permalink":"/terranetes-controller/admin/policy/checkov","draft":false,"unlisted":false,"editUrl":"https://github.com/appvia/terranetes/tree/master/docs/terranetes-controller/admin/policy/checkov.md","tags":[],"version":"current","lastUpdatedBy":"dependabot[bot]","lastUpdatedAt":1745161423000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_class_name":"green"},"sidebar":"tutorialSidebar","previous":{"title":"Module Restrictions","permalink":"/terranetes-controller/admin/policy/modules"},"next":{"title":"Contexts","permalink":"/terranetes-controller/admin/contexts"}}'),o=i("5893"),s=i("65");let r={sidebar_position:3,sidebar_class_name:"green"},a="Checkov Policy",c={},l=[{value:"Utilizing an External Policy Source",id:"utilizing-an-external-policy-source",level:2},{value:"Utilizing Checkov Policy Defaults",id:"utilizing-checkov-policy-defaults",level:2},{value:"Utilizing External Checks",id:"utilizing-external-checks",level:3},{value:"Rules for selecting the security policy",id:"rules-for-selecting-the-security-policy",level:2}];function h(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"checkov-policy",children:"Checkov Policy"})}),"\n",(0,o.jsx)(n.p,{children:"The implementation of a security policy ensures that platform teams can confidently allow self-service capabilities that adhere to the organization's best practices. As part of the plan stage, all Terraform configurations undergo a security check to validate their compliance."}),"\n",(0,o.jsxs)(n.p,{children:["Upon completion of the security check, the report is analyzed, and if no failed checks are identified, the configuration is permitted to proceed to the ",(0,o.jsx)(n.code,{children:"apply"})," stage, either automatically or through manual annotation."]}),"\n",(0,o.jsx)(n.h2,{id:"utilizing-an-external-policy-source",children:"Utilizing an External Policy Source"}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsx)(n.p,{children:"This method is highly recommended for implementing Checkov policy as it seamlessly integrates the various elements in the chain; from authoring to consumption. This allows the same policies to be referenced by your CI and runtime enforcement."}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Please note that this option is only available from version 0.3.7 and above."})})]}),"\n",(0,o.jsxs)(n.p,{children:["The controller has the capability to source an external repository used to store the Checkov policies. A common scenario would be a shared policy repository with Checkov configuration and external checks, shared between the ",(0,o.jsx)(n.a,{href:"/terranetes-controller/workflows/intro/",children:"Workflows"})," and this runtime enforcement."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Policy\nmetadata:\n  name: checkov\nspec:\n  constraints:\n    # Optional: This field allows you to specify the configurations to which the policy should apply. If left\n    # blank, this policy is a catch-all and will be applied to all terraform configurations.\n    selector:\n      # Used to filter on namespace labels\n      namespace:\n        matchLabels: {}\n        matchExpressions: []\n      # Used to filter on the configuration labels\n      resource:\n        matchLabels: {}\n        matchExpressions: []\n\n    checkov:\n      source:\n        # Is the path of the configuration file which holds the Checkov config i.e\n        # .checkov.yaml or config.yaml\n        configuration: PATH\n        # Is the source of the repository; the syntax for this follows the same\n        # format as for modules.\n        url: SOURCE\n        # This field optionally references a secret containing credentials necessary for sourcing the external repository. \n        # It is essential to note that this secret must reside within the same namespace as the controller.\n        secret:\n          name: NAME\n          namespace: NAMESPACE\n"})}),"\n",(0,o.jsx)(n.h2,{id:"utilizing-checkov-policy-defaults",children:"Utilizing Checkov Policy Defaults"}),"\n",(0,o.jsxs)(n.p,{children:["As an alternative, you can leverage the product's default settings and employ the ",(0,o.jsx)(n.code,{children:"skipChecks"})," and ",(0,o.jsx)(n.code,{children:"checks"})," toggles to selectively enable or disable specific checks. However, it is essential to note that this approach lacks a centralized policy framework, resulting in the enforcement policy being determined by the configuration of policies within the cluster."]}),"\n",(0,o.jsx)(n.p,{children:"The following Policy configuration exemplifies the structure for defining a Checkov policy that utilizes default settings and toggles for check management:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Policy\nmetadata:\n  name: checkov\nspec:\n  constraints:\n    # This field enables filtering of the configurations to which the policy should apply. \n    # If left blank, this policy becomes a catch-all, applying to all Terraform configurations.\n    selector:\n      # Utilized for filtering based on namespace labels\n      namespace:\n        matchLabels: {}\n        matchExpressions: []\n      # Utilized for filtering based on the configuration labels\n      resource:\n        matchLabels: {}\n        matchExpressions: []\n\n    checkov:\n      # For more information, refer to: https://www.checkov.io/5.Policy%20Index/terraform.html\n      checks: []\n      # For more information, refer to: https://www.checkov.io/5.Policy%20Index/terraform.html\n      skipChecks: []\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"important",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["In the absence of defined ",(0,o.jsx)(n.code,{children:"checkov.checks"}),", the entire Checkov suite is evaluated."]}),"\n",(0,o.jsxs)(n.li,{children:["If ",(0,o.jsx)(n.code,{children:"checkov.skipChecks"})," are specified, those checks are excluded from the evaluation process."]}),"\n"]})}),"\n",(0,o.jsx)(n.h3,{id:"utilizing-external-checks",children:"Utilizing External Checks"}),"\n",(0,o.jsxs)(n.p,{children:["The controller is capable of incorporating multiple ",(0,o.jsx)(n.a,{href:"https://www.checkov.io/3.Custom%20Policies/Custom%20Policies%20Overview.html",children:"custom policies"})," to enhance its policy enforcement capabilities."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Policy\nmetadata:\n  name: checkov\nspec:\n  constraints:\n    checkov:\n      external:\n        - name: custom\n          url: https://[LOCATION]\n          secretRef:\n            name: [SECRET]\n"})}),"\n",(0,o.jsx)(n.p,{children:"Key aspects to note:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["The URL adheres to the same format as the ",(0,o.jsx)(n.a,{href:"/terranetes-controller/reference/configurations.terraform.appvia.io",children:"Configuration"})," CRD, ensuring consistency in the way external resources are referenced."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"secretRef"})," field is optional and serves as a means to store credentials necessary for accessing the external assets. This aligns with the support for various asset sources, including object stores and git repositories, as seen in ",(0,o.jsx)(n.a,{href:"/terranetes-controller/reference/configurations.terraform.appvia.io",children:"Configurations"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Upon retrieval, all assets from the specified source are utilized as part of the ",(0,o.jsx)(n.a,{href:"https://www.checkov.io/2.Basics/CLI%20Command%20Reference.html",children:"external-checks-dir"})," option during the scan process, ensuring a comprehensive evaluation of the Terraform configurations."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"rules-for-selecting-the-security-policy",children:"Rules for selecting the security policy"}),"\n",(0,o.jsx)(n.p,{children:"Multiple checkov policies can be defined using selectors to target specific workloads, however, only one can match. The selection process is as follows:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"If the checkov policy does not have a selector, it is applied to all resources."}),"\n",(0,o.jsx)(n.li,{children:"If the checkov policy has a matching namespace selector, it adds additional priority/weight."}),"\n",(0,o.jsx)(n.li,{children:"If the checkov policy has a matching resource selector, it adds even more priority/weight."}),"\n",(0,o.jsx)(n.li,{children:"The total weights are added up, and the highest matching checkov policy is used."}),"\n",(0,o.jsx)(n.li,{children:"If you have checkov policies with the same weight, the controller throws an error."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Ultimately, the most specific checkov policy is selected for our Configuration."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Why not merge multiple policies?"})}),"\n",(0,o.jsx)(n.p,{children:"The idea of merging multiple policies was considered, but it was determined that adding an additional policy is needed to allow for an exception to the rule. For example, if we define that all RDS databases must use encryption, but project 'A' can't do that, we need an exception. However, policies are enforced because they strengthen security, so adding exceptions should be difficult/annoying in order to push for the better solution: fixing project A's lack of compliance."})]})}function d(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},65:function(e,n,i){i.d(n,{Z:function(){return a},a:function(){return r}});var t=i(7294);let o={},s=t.createContext(o);function r(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);