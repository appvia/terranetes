"use strict";(self.webpackChunkterranetes=self.webpackChunkterranetes||[]).push([["2476"],{1968:function(e,r,n){n.r(r),n.d(r,{metadata:()=>i,contentTitle:()=>a,default:()=>h,assets:()=>c,toc:()=>d,frontMatter:()=>s});var i=JSON.parse('{"id":"admin/providers","title":"Configuring Providers","description":"In the context of the controller, cloud access credentials are embodied by the Provider Custom Resource Definition (CRD), a cluster-scoped resource. When defining a Terraform module, developers reference a provider using the spec.providerRef field, thereby establishing a connection between the resource and the corresponding credentials.","source":"@site/docs/terranetes-controller/admin/providers.md","sourceDirName":"admin","slug":"/admin/providers","permalink":"/terranetes-controller/admin/providers","draft":false,"unlisted":false,"editUrl":"https://github.com/appvia/terranetes/tree/master/docs/terranetes-controller/admin/providers.md","tags":[],"version":"current","lastUpdatedBy":"dependabot[bot]","lastUpdatedAt":1745161936000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"sidebar_class_name":"green"},"sidebar":"tutorialSidebar","previous":{"title":"Administration","permalink":"/terranetes-controller/category/administration"},"next":{"title":"Define Guardrails","permalink":"/terranetes-controller/category/define-guardrails"}}'),t=n("5893"),o=n("65");let s={sidebar_position:1,sidebar_class_name:"green"},a="Configuring Providers",c={},d=[{value:"Utilizing a Provider",id:"utilizing-a-provider",level:2},{value:"Default Provider",id:"default-provider",level:3},{value:"Credential Configuration Options",id:"credential-configuration-options",level:2},{value:"Configuring Providers Using Secrets",id:"configuring-providers-using-secrets",level:3},{value:"Configuring Injected Identity",id:"configuring-injected-identity",level:3},{value:"Configuring IRSA for Amazon Web Services",id:"configuring-irsa-for-amazon-web-services",level:3},{value:"Configuring Azure AAD Pod Identity",id:"configuring-azure-aad-pod-identity",level:3},{value:"Service Account Permissions",id:"service-account-permissions",level:4},{value:"Configure RBAC for providers",id:"configure-rbac-for-providers",level:2},{value:"Provider Configuration",id:"provider-configuration",level:2}];function l(e){let r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"configuring-providers",children:"Configuring Providers"})}),"\n",(0,t.jsxs)(r.p,{children:["In the context of the controller, cloud access credentials are embodied by the ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," Custom Resource Definition (CRD), a cluster-scoped resource. When defining a Terraform module, developers reference a provider using the ",(0,t.jsx)(r.code,{children:"spec.providerRef"})," field, thereby establishing a connection between the resource and the corresponding credentials."]}),"\n",(0,t.jsxs)(r.admonition,{type:"important",children:[(0,t.jsx)(r.p,{children:"It is essential to note that credentials are confined within the controller namespace, effectively mitigating the risk of exposure."}),(0,t.jsx)(r.h2,{id:"utilizing-a-provider",children:"Utilizing a Provider"}),(0,t.jsxs)(r.p,{children:["To effectively reference a Provider within your Terraform configuration, the provider name must be referenced via ",(0,t.jsx)(r.code,{children:"spec.providerRef.name"}),":"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Configuration\nmetadata:\n  name: bucket\nspec:\n  providerRef:\n    name: aws\n  module: <url>\n  variables: {}\n"})}),(0,t.jsx)(r.h3,{id:"default-provider",children:"Default Provider"}),(0,t.jsxs)(r.p,{children:["To simplify the process for developers, platform administrators can designate a ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," as the default. This configuration ensures that any ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/configurations.terraform.appvia.io",children:"Configuration"})," lacking a specified ",(0,t.jsx)(r.code,{children:"spec.providerRef.name"})," will automatically utilize the default Provider."]}),(0,t.jsx)(r.admonition,{type:"important",children:(0,t.jsx)(r.p,{children:"Please note that this feature is only available starting from the v0.3.19 release."})})]}),"\n",(0,t.jsxs)(r.p,{children:["To mark a ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," as the default, administrators should apply the annotation ",(0,t.jsx)(r.code,{children:'terranetes.appvia.io/default-provider: "true"'}),". It is crucial to understand that only one ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," can be designated as the default at any given time."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:'---\napiVersion: terraform.appvia.io/v1alpha1\nkind: Provider\nmetadata:\n  name: aws\n  annotations:\n    terranetes.appvia.io/default-provider: "true"\nspec:\n'})}),"\n",(0,t.jsx)(r.h2,{id:"credential-configuration-options",children:"Credential Configuration Options"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," resource supports two primary methods for configuring credentials:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Secret-based Credentials"}),": Specified by ",(0,t.jsx)(r.code,{children:"spec.source: secret"}),", this approach references a Kubernetes secret, which is then mounted as environment variables within the executor. This method is suitable for static credentials."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Injected Credentials"}),": Identified by ",(0,t.jsx)(r.code,{children:"spec.source: injected"}),", this option runs the executor with a predefined service account. This configuration is particularly useful for supporting pod identity or IRSA (Identity and Resource Access Management Service) in AWS environments."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"A detailed explanation of these credential configuration options is provided below."}),"\n",(0,t.jsx)(r.h3,{id:"configuring-providers-using-secrets",children:"Configuring Providers Using Secrets"}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsx)(r.p,{children:"While static credentials offer a straightforward approach to getting started, we strongly recommend adopting pod identity and delegating credentials management to the cloud provider for enhanced security and manageability."})}),"\n",(0,t.jsxs)(r.p,{children:["Terraform providers universally support configuration through environment variables. For instance, when working with AWS, you can utilize ",(0,t.jsx)(r.code,{children:"AWS_REGION"}),", ",(0,t.jsx)(r.code,{children:"AWS_ACCESS_KEY_ID"}),", and ",(0,t.jsx)(r.code,{children:"AWS_SECRET_ACCESS_KEY"}),". To implement this, create a Kubernetes secret within the controller namespace (defaulting to ",(0,t.jsx)(r.code,{children:"terraform-system"}),") that defines these environment variables:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-shell",children:"$ kubectl -n terraform-system create secret generic aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=<ID> \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=<SECRET> \\\n  --from-literal=AWS_REGION=<REGION>\n"})}),"\n",(0,t.jsx)(r.admonition,{type:"important",children:(0,t.jsx)(r.p,{children:"It is crucial to note that static credentials secrets must reside within the same namespace as the Terraform controller itself. This is because the credentials are mounted into the job as environment variables."})}),"\n",(0,t.jsx)(r.p,{children:"This process applies uniformly to all supported providers:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://registry.terraform.io/providers/hashicorp/aws/latest/docs",children:"Amazon"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://registry.terraform.io/providers/hashicorp/google/latest",children:"Google Cloud"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs",children:"Azure"})}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Currently, we support the use of ",(0,t.jsx)(r.code,{children:"google"}),", ",(0,t.jsx)(r.code,{children:"aws"}),", and ",(0,t.jsx)(r.code,{children:"azurerm"})," as providers. Although the controller is not limited to these providers, any additional providers must be defined within the module."]}),"\n",(0,t.jsx)(r.p,{children:"After provisioning the secret, you can create a Provider for it:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Provider\nmetadata:\n  # This name should match the `providerRef` in the Configuration.\n  name: default\nspec:\n  summary: Default providers for all configurations\n  source: secret\n  provider: aws\n  secretRef:\n    namespace: terraform-system\n    name: aws\n"})}),"\n",(0,t.jsx)(r.h3,{id:"configuring-injected-identity",children:"Configuring Injected Identity"}),"\n",(0,t.jsx)(r.p,{children:"Injected identity configurations are referred to by different names depending on the cloud provider in use. Specifically:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["Amazon Web Services (AWS) - ",(0,t.jsx)(r.a,{href:"https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up-enable-IAM.html",children:"IRSA"})]}),"\n",(0,t.jsxs)(r.li,{children:["Google Cloud Platform - ",(0,t.jsx)(r.a,{href:"https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity",children:"workload identity"})]}),"\n",(0,t.jsxs)(r.li,{children:["Microsoft Azure - ",(0,t.jsx)(r.a,{href:"https://docs.microsoft.com/en-us/azure/aks/use-azure-ad-pod-identity",children:"pod identity"})]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Across all these cloud providers, the injected identity mechanism serves a common purpose:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"One or more roles are defined within the cloud provider, each with explicitly assigned permissions."}),"\n",(0,t.jsxs)(r.li,{children:["A cloud provider-specific binding is established, granting a Kubernetes ",(0,t.jsx)(r.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",children:"service account"})," the capability to obtain short-lived credentials for a specified role."]}),"\n",(0,t.jsx)(r.li,{children:"The cloud provider generates ephemeral credentials and supplies them to the workload."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"This approach effectively delegates all credentials management to the cloud provider, ensuring that the credentials utilized are transient and expire, thereby enhancing overall security."}),"\n",(0,t.jsx)(r.p,{children:"The process of configuring injected identities is specific to each cloud provider, and the detailed procedures are outside the scope of this document."}),"\n",(0,t.jsx)(r.h3,{id:"configuring-irsa-for-amazon-web-services",children:"Configuring IRSA for Amazon Web Services"}),"\n",(0,t.jsxs)(r.p,{children:["To utilize IRSA with EKS, it is essential to first configure an OIDC connector. For a detailed explanation, refer to the ",(0,t.jsx)(r.a,{href:"https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts-technical-overview.html",children:"Technical Overview"}),"."]}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsxs)(r.p,{children:["For clusters created using Terraform, consider utilizing the Terraform module at ",(0,t.jsx)(r.a,{href:"https://registry.terraform.io/modules/terraform-aws-modules/iam/aws/latest/submodules/iam-role-for-service-accounts-eks",children:"https://registry.terraform.io/modules/terraform-aws-modules/iam/aws/latest/submodules/iam-role-for-service-accounts-eks"}),"."]})}),"\n",(0,t.jsx)(r.p,{children:"Next, update your Helm values as shown in the example below. The crucial aspect is the annotation for the service account employed by the executor, which must include the ARN of the role to be utilized."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"rbac:\n  # Indicates the creation of all necessary RBAC resources\n  create: true\n  # ServiceAccount for the controller\n  controller:\n    # Indicates the creation of the terranetes-controller service account\n    create: true\n    # annotations is a collection of annotations to be added to the ServiceAccount\n    annotations: {}\n\n  # Configuration for the terraform executor service account\n  executor:\n    # Indicates the creation of the terraform-executor service account\n    create: true\n    # annotations is a collection of annotations to be added to the ServiceAccount\n    annotations:\n      eks.amazonaws.com/role-arn: arn:aws:iam::<AWS_ACCOUNT_ID>:role/<NAME_OF_ROLE>\n"})}),"\n",(0,t.jsx)(r.p,{children:"Upon pod creation:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"The EKS control plane identifies the annotation on the service account."}),"\n",(0,t.jsx)(r.li,{children:"It verifies the existence of a binding between the service account and the specified IAM role."}),"\n",(0,t.jsx)(r.li,{children:"If a binding is found, it generates credentials and injects them via a secret as environment variables into the pod."}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"configuring-azure-aad-pod-identity",children:"Configuring Azure AAD Pod Identity"}),"\n",(0,t.jsx)(r.p,{children:"To effectively utilize Azure's Pod identity service, the following steps must be undertaken:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Ensure Provider MSI Configuration"}),": It is essential to configure the Provider with the ",(0,t.jsx)(r.code,{children:"use_msi: true"})," setting to enable the use of Managed Service Identity (MSI) for authentication. This configuration is crucial to prevent the AzureRM provider from attempting to fallback to the ",(0,t.jsx)(r.code,{children:"az"})," CLI, which may result in errors due to the absence of the binary."]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Provider\nmetadata:\n  name: azurerm\nspec:\n  configuration:\n    subscription_id: AZURE_SUBSCRIPTION_ID\n    tenant_id: AZURE_TENANT_ID\n    use_msi: true\n  source: injected\n  provider: azurerm\n"})}),"\n",(0,t.jsxs)(r.ol,{start:"2",children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Provision Azure Identity in Subscription"}),": Follow the standard walkthrough for provisioning Azure Identity in the subscription, as outlined in the Azure documentation (",(0,t.jsx)(r.a,{href:"https://azure.github.io/aad-pod-identity/docs/demo/standard_walkthrough/",children:"https://azure.github.io/aad-pod-identity/docs/demo/standard_walkthrough/"}),")."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Provision Azure Identity in Controller Namespace"}),": Create an AzureIdentity resource in the controller namespace to manage the identity for the pods within that namespace."]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: aadpodidentity.k8s.io/v1\nkind: AzureIdentity\nmetadata:\n  annotations:\n    aadpodidentity.k8s.io/Behavior: namespaced\n  generation: 3\n  name: terranetes-controller\n  namespace: terraform-system\nspec:\n  clientID: CLIENT_ID\n  resourceID: /subscriptions/SUBSCRIPTION/resourcegroups/RESOURCE_GROUP/providers/Microsoft.ManagedIdentity/userAssignedIdentities/IDENTITY\n  type: 0\n"})}),"\n",(0,t.jsxs)(r.ol,{start:"4",children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Provision Binding to Pods"}),": Create an AzureIdentityBinding resource to associate the AzureIdentity with the pods that require access to the Azure resources. This binding is crucial for filtering pods in the namespace and granting them the necessary permissions."]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: aadpodidentity.k8s.io/v1\nkind: AzureIdentityBinding\nmetadata:\n  name: terranetes-controller\n  namespace: terraform-system\nspec:\n  azureIdentity: IDENTITY\n  selector: terranetes-executor\n"})}),"\n",(0,t.jsxs)(r.admonition,{type:"caution",children:[(0,t.jsxs)(r.p,{children:["Details on binding can be found ",(0,t.jsx)(r.a,{href:"https://azure.github.io/aad-pod-identity/docs/concepts/azureidentitybinding/",children:"here"}),"."]}),(0,t.jsxs)(r.p,{children:["As of <= v0.3.30 the pod selector is not configurable in the controller to ensure you use ",(0,t.jsx)(r.code,{children:"terranetes-executor"})," on the binding."]})]}),"\n",(0,t.jsx)(r.h4,{id:"service-account-permissions",children:"Service Account Permissions"}),"\n",(0,t.jsx)(r.p,{children:"It is crucial to ensure the correct Role-Based Access Control (RBAC) permissions are in place when utilizing or creating additional service accounts for a Provider. This is particularly important when referencing a service account in a Provider that leverages IRSA, such as 'admin' in the terraform-system namespace."}),"\n",(0,t.jsxs)(r.p,{children:["By default, the terraform controller employs the service account 'terraform-executor' to execute jobs. If you require additional service accounts for Providers, for instance, to use with ",(0,t.jsx)(r.code,{children:"spec.source: injected"})," or to utilize another service account, it is essential to establish the correct RBAC permissions. The terraform job relies on Kubernetes secrets to store the terraform state and leases for locking purposes. Therefore, the following permissions must be configured:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: NAME_OF_ROLE\n  namespace: terraform-system\nrules:\n  - apiGroups:\n      - coordination.k8s.io\n    resources:\n      - leases\n    verbs:\n      - create\n      - delete\n      - get\n      - list\n      - update\n      - watch\n  - apiGroups:\n      - ""\n    resources:\n      - configmaps\n    verbs:\n      - get\n      - list\n      - watch\n  - apiGroups:\n      - ""\n    resources:\n      - secrets\n    verbs:\n      - create\n      - delete\n      - get\n      - list\n      - patch\n      - update\n      - watch\n'})}),"\n",(0,t.jsx)(r.p,{children:"Additionally, a RoleBinding is required to associate the Role with the service account."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"  ---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: terraform-executor\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n    name: NAME_OF_ROLE\nsubjects:\n  - kind: ServiceAccount\n    name: terraform-executor\n    namespace: terraform-system\n"})}),"\n",(0,t.jsx)(r.p,{children:"The absence of these permissions will result in terraform execution failures due to access denied errors on secrets and/or leases."}),"\n",(0,t.jsx)(r.h2,{id:"configure-rbac-for-providers",children:"Configure RBAC for providers"}),"\n",(0,t.jsxs)(r.p,{children:["Providers support the ability to filter who can use them. When a ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io#v1alpha1-.spec.selector",children:(0,t.jsx)(r.code,{children:"spec.selector"})})," is defined on the provider, any configuration referencing it must pass the filter, otherwise it will fail."]}),"\n",(0,t.jsxs)(r.p,{children:["It is important to note that by default an empty ",(0,t.jsx)(r.code,{children:"spec.selector"})," dictates all ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/configurations.terraform.appvia.io",children:"Configurations"})," in the cluster can use it. This is useful to provide limited scope credentials to all teams."]}),"\n",(0,t.jsxs)(r.p,{children:["Using the ",(0,t.jsx)(r.code,{children:"spec.selector"})," field you can scope the credentials based on namespace and resource labels. For example you could add a ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," for system namespaces only:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Provider\nmetadata:\n  # This name should match the `providerRef` in the Terraform Configuration (see above example).\n  name: admin\nspec:\n  selector:\n    namespace:\n      matchExpressions:\n        - key: kubernetes.io/metadata.name\n          operator: In\n          values: [kube-system]\n  source: secret\n  provider: aws\n  secretRef:\n    namespace: terraform-system\n    name: admin\n"})}),"\n",(0,t.jsx)(r.p,{children:"Concurrently, you can offer a distinct set of limited permissions to all cluster users by omitting the selector."}),"\n",(0,t.jsxs)(r.p,{children:["This feature also enables the mapping of different pod identity roles to cloud vendors or distinct service accounts linked to ",(0,t.jsx)(r.a,{href:"https://www.vaultproject.io/",children:"Vault"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"provider-configuration",children:"Provider Configuration"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"spec.configuration"})," field within the ",(0,t.jsx)(r.a,{href:"/terranetes-controller/reference/providers.terraform.appvia.io",children:"Provider"})," resource allows for the integration of supplementary configuration settings. A notable example is the Azure provider, which includes a ",(0,t.jsx)(r.a,{href:"https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/guides/features-block",children:"features"})," block that can be specifically tailored within the provider configuration."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yaml",children:"apiVersion: terraform.appvia.io/v1alpha1\nkind: Provider\nmetadata:\n  name: azure\nspec:\n  # Anything in configuration section is converting to HCL and configured the provider\n  configuration:\n    features:\n      api_management:\n        purge_soft_delete_on_destroy: true\n        recover_soft_deleted_api_managements: true\n      virtual_machine:\n        graceful_shutdown: true\n  source: secret\n  provider: azurerm\n  secretRef:\n    namespace: terraform-system\n    name: admin\n"})})]})}function h(e={}){let{wrapper:r}={...(0,o.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},65:function(e,r,n){n.d(r,{Z:function(){return a},a:function(){return s}});var i=n(7294);let t={},o=i.createContext(t);function s(e){let r=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:r},e.children)}}}]);