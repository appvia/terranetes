"use strict";(self.webpackChunkterraform_controller_docs=self.webpackChunkterraform_controller_docs||[]).push([[826],{3905:function(e,t,s){s.d(t,{Zo:function(){return n},kt:function(){return h}});var r=s(7294);function a(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function p(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,r)}return s}function o(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?p(Object(s),!0).forEach((function(t){a(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):p(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function i(e,t){if(null==e)return{};var s,r,a=function(e,t){if(null==e)return{};var s,r,a={},p=Object.keys(e);for(r=0;r<p.length;r++)s=p[r],t.indexOf(s)>=0||(a[s]=e[s]);return a}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(r=0;r<p.length;r++)s=p[r],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(a[s]=e[s])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),s=t;return e&&(s="function"==typeof e?e(t):o(o({},t),e)),s},n=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var s=e.components,a=e.mdxType,p=e.originalType,c=e.parentName,n=i(e,["components","mdxType","originalType","parentName"]),y=l(s),h=a,k=y["".concat(c,".").concat(h)]||y[h]||d[h]||p;return s?r.createElement(k,o(o({ref:t},n),{},{components:s})):r.createElement(k,o({ref:t},n))}));function h(e,t){var s=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var p=s.length,o=new Array(p);o[0]=y;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var l=2;l<p;l++)o[l]=s[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,s)}y.displayName="MDXCreateElement"},7384:function(e,t,s){s.r(t),s.d(t,{assets:function(){return n},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return d}});var r=s(7462),a=s(3366),p=(s(7294),s(3905)),o=["components"],i={title:"policies.terraform.appvia.io",linkTitle:"Policy",sidebar_position:1},c="Policy",l={unversionedId:"reference/policies.terraform.appvia.io",id:"reference/policies.terraform.appvia.io",title:"policies.terraform.appvia.io",description:"Policy is the schema for provider definitions in terraform controller",source:"@site/docs/terraform-controller/reference/policies.terraform.appvia.io.md",sourceDirName:"reference",slug:"/reference/policies.terraform.appvia.io",permalink:"/terraform-controller/reference/policies.terraform.appvia.io",draft:!1,editUrl:"https://github.com/appvia/terranetes/tree/master/docs/terraform-controller/reference/policies.terraform.appvia.io.md",tags:[],version:"current",lastUpdatedBy:"Rohith Jayawardene",lastUpdatedAt:1653502442,formattedLastUpdatedAt:"5/25/2022",sidebarPosition:1,frontMatter:{title:"policies.terraform.appvia.io",linkTitle:"Policy",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"configurations.terraform.appvia.io",permalink:"/terraform-controller/reference/configurations.terraform.appvia.io"},next:{title:"providers.terraform.appvia.io",permalink:"/terraform-controller/reference/providers.terraform.appvia.io"}},n={},d=[],y={toc:d};function h(e){var t=e.components,s=(0,a.Z)(e,o);return(0,p.kt)("wrapper",(0,r.Z)({},y,s,{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"policy"},"Policy"),(0,p.kt)("p",{class:"crd-description"},"Policy is the schema for provider definitions in terraform controller"),(0,p.kt)("dl",{class:"crd-meta"},(0,p.kt)("dt",{class:"fullname"},"Full name:"),(0,p.kt)("dd",{class:"fullname"},"policies.terraform.appvia.io"),(0,p.kt)("dt",{class:"groupname"},"Group:"),(0,p.kt)("dd",{class:"groupname"},"terraform.appvia.io"),(0,p.kt)("dt",{class:"singularname"},"Singular name:"),(0,p.kt)("dd",{class:"singularname"},"policy"),(0,p.kt)("dt",{class:"pluralname"},"Plural name:"),(0,p.kt)("dd",{class:"pluralname"},"policies"),(0,p.kt)("dt",{class:"scope"},"Scope:"),(0,p.kt)("dd",{class:"scope"},"Cluster"),(0,p.kt)("dt",{class:"versions"},"Versions:"),(0,p.kt)("dd",{class:"versions"},(0,p.kt)("a",{class:"version",href:"#v1alpha1",title:"Show schema for version v1alpha1"},"v1alpha1"))),(0,p.kt)("div",{class:"crd-schema-version"},(0,p.kt)("h2",{id:"v1alpha1"},"Version v1alpha1"),(0,p.kt)("h3",{id:"property-details-v1alpha1"},"Properties"),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.apiVersion"},".apiVersion")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: ",(0,p.kt)("a",{href:"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"},"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"))))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.kind"},".kind")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: ",(0,p.kt)("a",{href:"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"},"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"))))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.metadata"},".metadata")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec"},".spec")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"PolicySpec defines the desired state of a provider")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints"},".spec.constraints")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Constraints provides a series or constraints that must be enforced on the selectored terraform configurations.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov"},".spec.constraints.checkov")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Checkov provides the ability to enforce a set of security standards on all configurations. These can be configured to target specific resources based on namespace and resource labels")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.checks"},".spec.constraints.checkov.checks")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Checks is a list of checks which should be applied against the configuration. Note, an empty list here implies checkov should run ALL checks. Please see ",(0,p.kt)("a",{href:"https://www.checkov.io/5.Policy%20Index/terraform.html"},"https://www.checkov.io/5.Policy%20Index/terraform.html"))))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.checks[*]"},".spec.constraints.checkov.checks[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector"},".spec.constraints.checkov.selector")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Selector is the selector on the namespace or labels on the configuration. By leaving this fields empty you can implicitedly selecting all configurations.")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace"},".spec.constraints.checkov.selector.namespace")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Namespace is used to filter a configuration based on the namespace labels of where it exists")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchExpressions"},".spec.constraints.checkov.selector.namespace.matchExpressions")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"matchExpressions is a list of label selector requirements. The requirements are ANDed.")))),(0,p.kt)("div",{class:"property depth-6"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchExpressions[*]"},".spec.constraints.checkov.selector.namespace.matchExpressions[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchExpressions[*].key"},".spec.constraints.checkov.selector.namespace.matchExpressions[*].key")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"key is the label key that the selector applies to.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchExpressions[*].operator"},".spec.constraints.checkov.selector.namespace.matchExpressions[*].operator")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchExpressions[*].values"},".spec.constraints.checkov.selector.namespace.matchExpressions[*].values")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.")))),(0,p.kt)("div",{class:"property depth-8"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchExpressions[*].values[*]"},".spec.constraints.checkov.selector.namespace.matchExpressions[*].values[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.namespace.matchLabels"},".spec.constraints.checkov.selector.namespace.matchLabels")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource"},".spec.constraints.checkov.selector.resource")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Resource provides the ability to filter a configuration based on it\u2019s labels")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchExpressions"},".spec.constraints.checkov.selector.resource.matchExpressions")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"matchExpressions is a list of label selector requirements. The requirements are ANDed.")))),(0,p.kt)("div",{class:"property depth-6"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchExpressions[*]"},".spec.constraints.checkov.selector.resource.matchExpressions[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchExpressions[*].key"},".spec.constraints.checkov.selector.resource.matchExpressions[*].key")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"key is the label key that the selector applies to.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchExpressions[*].operator"},".spec.constraints.checkov.selector.resource.matchExpressions[*].operator")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchExpressions[*].values"},".spec.constraints.checkov.selector.resource.matchExpressions[*].values")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.")))),(0,p.kt)("div",{class:"property depth-8"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchExpressions[*].values[*]"},".spec.constraints.checkov.selector.resource.matchExpressions[*].values[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.selector.resource.matchLabels"},".spec.constraints.checkov.selector.resource.matchLabels")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.skipChecks"},".spec.constraints.checkov.skipChecks")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"SkipChecks is a collection of checkov checks which you can defined as skipped. The security scan will ignore any failures on these checks.")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.checkov.skipChecks[*]"},".spec.constraints.checkov.skipChecks[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.modules"},".spec.constraints.modules")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Modules provides the ability to control the source for all terraform modules. Allowing platform teams to control where the modules can be downloaded from.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.modules.allowed"},".spec.constraints.modules.allowed")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Allowed is a collection of regexes which are applied to the source of the terraform configuration. The configuration MUST match one or more of the regexes in order to be allowed to run.")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.constraints.modules.allowed[*]"},".spec.constraints.modules.allowed[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults"},".spec.defaults")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Defaults provides the ability to target specific terraform module based on namespace or resource labels and automatically inject variables into the configurations.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*]"},".spec.defaults[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"DefaultVariables provides platform administrators the ability to inject default variables into a configuration")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector"},".spec.defaults[*].selector")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Selector is used to determine which configurations the variables should be injected into")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.modules"},".spec.defaults[*].selector.modules")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Modules provides a collection of regexes which are used to match against the configuration module")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.modules[*]"},".spec.defaults[*].selector.modules[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-4"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace"},".spec.defaults[*].selector.namespace")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Namespace selectors all configurations under one or more namespaces, determined by the labeling on the namespace.")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchExpressions"},".spec.defaults[*].selector.namespace.matchExpressions")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"matchExpressions is a list of label selector requirements. The requirements are ANDed.")))),(0,p.kt)("div",{class:"property depth-6"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchExpressions[*]"},".spec.defaults[*].selector.namespace.matchExpressions[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchExpressions[*].key"},".spec.defaults[*].selector.namespace.matchExpressions[*].key")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"key is the label key that the selector applies to.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchExpressions[*].operator"},".spec.defaults[*].selector.namespace.matchExpressions[*].operator")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.")))),(0,p.kt)("div",{class:"property depth-7"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchExpressions[*].values"},".spec.defaults[*].selector.namespace.matchExpressions[*].values")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.")))),(0,p.kt)("div",{class:"property depth-8"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchExpressions[*].values[*]"},".spec.defaults[*].selector.namespace.matchExpressions[*].values[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")))),(0,p.kt)("div",{class:"property depth-5"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].selector.namespace.matchLabels"},".spec.defaults[*].selector.namespace.matchLabels")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.defaults[*].variables"},".spec.defaults[*].variables")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Variables is a collection of variables to inject into the configuration")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.spec.summary"},".spec.summary")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Summary is an optional field which can be used to define a summary of what the policy is configured to enforce.")))),(0,p.kt)("div",{class:"property depth-0"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status"},".status")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"PolicyStatus defines the observed state of a provider")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions"},".status.conditions")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"array")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Conditions represents the observations of the resource\u2019s current state.")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*]"},".status.conditions[*]")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Condition is the current observed condition of some aspect of a resource")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].detail"},".status.conditions[*].detail")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Detail is any additional human-readable detail to understand this condition, for example, the full underlying error which caused an issue")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].lastTransitionTime"},".status.conditions[*].lastTransitionTime")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"LastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].message"},".status.conditions[*].message")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Message is a human readable message indicating details about the transition. This may be an empty string.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].name"},".status.conditions[*].name")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Name is a human-readable name for this condition.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].observedGeneration"},".status.conditions[*].observedGeneration")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"ObservedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].reason"},".status.conditions[*].reason")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Reason contains a programmatic identifier indicating the reason for the condition\u2019s last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].status"},".status.conditions[*].status")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Status of the condition, one of True, False, Unknown.")))),(0,p.kt)("div",{class:"property depth-3"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.conditions[*].type"},".status.conditions[*].type")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string"),(0,p.kt)("span",{class:"property-required"},"Required")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Type of condition in CamelCase or in foo.example.com/CamelCase. \u2014 Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastReconcile"},".status.lastReconcile")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"LastReconcile describes the generation and time of the last reconciliation")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastReconcile.generation"},".status.lastReconcile.generation")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Generation is the generation reconciled on the last reconciliation")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastReconcile.time"},".status.lastReconcile.time")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Time is the last time the resource was reconciled")))),(0,p.kt)("div",{class:"property depth-1"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastSuccess"},".status.lastSuccess")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"object")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"LastSuccess descibes the generation and time of the last reconciliation which resulted in a Success status")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastSuccess.generation"},".status.lastSuccess.generation")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"integer")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Generation is the generation reconciled on the last reconciliation")))),(0,p.kt)("div",{class:"property depth-2"},(0,p.kt)("div",{class:"property-header"},(0,p.kt)("h3",{class:"property-path",id:"v1alpha1-.status.lastSuccess.time"},".status.lastSuccess.time")),(0,p.kt)("div",{class:"property-body"},(0,p.kt)("div",{class:"property-meta"},(0,p.kt)("span",{class:"property-type"},"string")),(0,p.kt)("div",{class:"property-description"},(0,p.kt)("p",null,"Time is the last time the resource was reconciled"))))))}h.isMDXComponent=!0}}]);